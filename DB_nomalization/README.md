# :runner: 데이터베이스 정규화 
### :bulb: 데이터베이스 정규화란?
- 데이터베이스의 설계를 재구성하는 테크닉
- 불필요한 데이터를 없앨 수 있고, 삽입/갱신/삭제 시 발생할 수 있는 각종 이상현상을 방지할 수 있다.

### :bulb: 정규화의 목적
1. 불필요한 데이터(data redundancy)를 제거한다.
2. 데이터 저장을 '__논리적__'으로 한다. 
- 데이터 저장을 논리적으로 한다는 것은 테이블 구성이 논리적이고 직관적이어야 한다는 것. 

|S_id|S_Name|S_Address|Subject_opted|
|---|---|---|---|
|101|Adam|Noida|Bio|
|102|Alex|Panipat|Maths|
|103|Stuart|ammu|Maths|
|104|Adam|Noida|Physics|

위와 같이 정규화가 되지 않은 구조의 테이블의 경우, 데이터 핸들링시 다양한 이상현상이 발생하게 된다.(Adam이 중복)
 
 1. __Update__ : Adam의 Address가 변경되었을 때, 여러줄의 데이터를 갱신해야한다. 이로인해 데이터의 불일치가 발생할 수 있다.
 2. __Inserte__ : 만약 학생이 아무 과목도 수강하지 않는다고 하면, Subject_opted 컬럼에는 NULL이 들어감.
 3. __Deletion__ : 만약 Alex 학생이 과목 수강을 취소한다면 Alex의 레코드가 아예 테이블에서 지워짐.
  
  위와 같이 정규화가 제대로 되지 않은 테이블의 경우 갱신/삽입/삭제 시 다양한 문제점이 발생할 수 있다. 테이블 구성을 논리적으로 변경하여 문제를 해결하고자 하는 것이 바로 정규화이다.
   
  - 정규화의 법칙(Normalazation Rule)은 1차 정규화, 2차 정규화, 3차 정규화, BCNF, 4차 정규화, 5차 정규화로 나눌 수 있다.  
   실무적으로는 4차,5차까지 하는경우는 많지 않다고 한다.
  
 __1. 1차 정규화__
  
  1차 정규형은 각 로우(row)마다 컬럼(column)의 값이 1개씩만 있어야 한다. 이를 컬럼이 __원자값__(Atomic Value)를 갖는다고 한다.
  예를 들어, 아래와 같은 경우 Adam의 Subject가 Bio와 Physics 두 개 이기 때문에 1차 정규형을 만족하지 못한다.
  
  |Student|Age|Subject|
  |---|---|---|
  |Adam|15|Bio,Physics|
  |Alex|14|Maths|
  |Stuart|17|Maths|
   
  위의 정보를 표현하고 싶은 경우 이렇게 한 개의 로우(row)를 더 만들어야 한다. 결과적으로 1차 정규화를 함으로써 데이터 redundancy는 증가함.
  데이터의 논리적 구성을 위해 이 부분을 희생하는 것으로 볼 수 있다.
  
  __2. 2차 정규화__
  
  2차 정규화부터가 본격적인 정규화의 시작. 2차 정규형은 테이블의 모든 컬럼이 '__완전 함수적 종속__'을 만족하는것. 
  
  기본 키 중에 특정 컬럼에만 '__종속된 컬럼(부분적 종속)이 없어야 한다__'는 것.  
  위 테이블의 경우 기본키는 Student, Subject 두 개로 볼 수 있다. 근데 Age의 경우 기본 키 중 Student에만 종속되어 있다.  
  즉, Student 컬럼의 값을 알면 Age의 값을 알 수 있다. 따라서 Age가 두 번 들어가는 것은 불필요한 것으로 볼 수 있다.  
  
  - Student Table
  
  |Student|Age|
  |---|---|
  |Adam|15|
  |Alex|14|
  |Stuart|17|
  
  - Subject Table
  
  |Student|Subject|
  |---|---|
  |Adam|Bio|
  |Adam|Physics|
  |Alex|Maths|
  |Stuart|Maths|
  
  - 이를 해결하기 위한 방법은 위처럼 테이블을 쪼개는 것. 그러면 두 테이블 모두 __2차 정규형을 만족__하게 된다.
  위 테이블의 경우 삽입/갱신/삭제 이상을 겪지 않게된다. 하지만 조금 더 복자반 테이블의 경우, 갱신 이상을 겪기도 하는데 이를 해결하는 것이 바로 __3차 정규화__이다.
  
  __3. 3차 정규화__
  
  - Student_Detail Table : 
  
  |Student_id|Student_name|DOB|Street|City|State|Zip|
  |---|---|---|---|---|---|---|
  
  이와 같은 데이터 구성을 보면, Student_id가 기본키이고, 기본키가 하나이므로 2차 정규형은 만족.
  하지만, 데이터의 Zip컬럼을 알면 Street,City,State를 결정 할수 있다. 또한 여러명의 학생들이 같은 Zip코드를 갖는 경우에만 Zip코드만 알면 Street,City,State가 결정되기 때문에 이 커럼들에는 중복된 데이터가 생길 가능성이 있다.
  정리하자면, __'3차 정규형은 기본키를 제외한 속성들 간의 이행적 함수 종속이 없다'__는 것. 
  기본키 이외의 다른 컬럼이 그 외 다른 컬럼을 결정할 수 없는 것.
  
  3차 정규화는 2차 정규화와 마찬가지로 테이블을 분리함으로써 해결할 수 있다. 
  아래와 같이 두 개의 테이블로 나눔으로써 3차 정규형을 만족. 이를 통해 데이터가 논리적인 단위(학생,주소)로 분리될 수 있고, 데이터의 redundancy도 줄었음을 알 수 있다.
  - New Student_Detail Table : 
  
  |Student_id|Student_name|Zip|
  |---|---|---|
  
  - Address Table : 
  
  |Zip|Street|City|State|
  |---|---|---|---|
  
  __4. BCNF__
  
  BCNF(Boyce and Codd Normal Form)는 3차 정규형을 조금 더 강화한 버전.
  3차 정규형으로 해결할 수 없는 이상현상을 해결할 수 있다. BCNF란 3차 정규형을 만족하면서 __모든 결정자가 후보키에 집합에 속한 정규형__이다.
  아래와 같은 경우를 생각해보면, 후보키는 슈퍼키 중에서 최소성을 만족하는건데, 이 경우(학생,과목)이다.
  학생,과목은 그 로우(row)를 유일하게 구분할 수 있다. 근데 이 테이블의 경우 __교수__가 __결정자__이다. (교수가 한 과목만 강의할 수 있다고 가정)
  즉, 교수가 정해지면 과목이 결정된다. 하지만 __교수는 후보키가 아니다__. 따라서 이 경우 __BCNF를 만족하지 못한다__고 본다. 
  - 3차 정규형을 만족하면서 BCNF를 만족하지 않는 경우? __일반 컬럼이 후보키를 결정하는 경우__
  
  |학생|과목|교수|학점|
  |---|---|---|---|
  |1|인문학|김은영|A|
  |2|대학영어|Mr.Sim|A|
  |3|대학영어|Mr.Sim|A|
  
  위 같이 테이블이 구성된 경우 데이터가 중복되고, 갱신 이상이 발생
  예를 들어, Mr.Sim이 강의하는 과목명이 바뀌었다면 2개의 row를 갱신해야 한다.
  이를 해결하기 위해 테이블을 분리함.
  
  - 교수 테이블 :
  
  |교수|과목|
  |---|---|
  |김인영|인문학|
  |Mr.Sim|대학영어|
  
  - 수강 테이블 : 
  
  |학생|과목|학점|
  |---|---|---|
  |1|인문학|A| 
  |2|대학영어|A| 
  |3|대학영어|A| 
  
  
  
- 참고 

[tistory 게시글] (https://3months.tistory.com/193)
